## This test is design to figure out the cost when put in the solutions generated by different scenario sizes.
#  That is, scenario size = [20, 50, 100, 200], we obtain the first-stage decision for each case
#  And test this decision to a new data set scenario size = 500





## -----------------------------------  Generate the first-stage decision  ---------------------------------------- ##
gurobiResultList = totalCost = Dict{Int64, Any}()
## scenario size = 20
indexSets = load("src/testData/RTS_24_20/indexSets.jld2")["indexSets"]
paramOPF = load("src/testData/RTS_24_20/paramOPF.jld2")["paramOPF"]
paramDemand = load("src/testData/RTS_24_20/paramDemand.jld2")["paramDemand"]
Ω_rv = load("src/testData/RTS_24_20/Ω_rv.jld2")["Ω_rv"]
prob = load("src/testData/RTS_24_20/prob.jld2")["prob"]

@time gurobiResult = gurobiOptimize!(indexSets, 
                                    paramDemand, 
                                    paramOPF, 
                                    Ω_rv,
                                    prob); 
gurobiResultList[20] = gurobiResult;


## scenario size = 50
indexSets = load("src/testData/RTS_24_50/indexSets.jld2")["indexSets"]
paramOPF = load("src/testData/RTS_24_50/paramOPF.jld2")["paramOPF"]
paramDemand = load("src/testData/RTS_24_50/paramDemand.jld2")["paramDemand"]
Ω_rv = load("src/testData/RTS_24_50/Ω_rv.jld2")["Ω_rv"]
prob = load("src/testData/RTS_24_50/prob.jld2")["prob"]

@time gurobiResult = gurobiOptimize!(indexSets, 
                                    paramDemand, 
                                    paramOPF, 
                                    Ω_rv,
                                    prob; timelimit = 7200); 
gurobiResultList[50] = gurobiResult;


## scenario size = 100
indexSets = load("src/testData/RTS_24_100/indexSets.jld2")["indexSets"]
paramOPF = load("src/testData/RTS_24_100/paramOPF.jld2")["paramOPF"]
paramDemand = load("src/testData/RTS_24_100/paramDemand.jld2")["paramDemand"]
Ω_rv = load("src/testData/RTS_24_100/Ω_rv.jld2")["Ω_rv"]
prob = load("src/testData/RTS_24_100/prob.jld2")["prob"]

@time gurobiResult = gurobiOptimize!(indexSets, 
                                    paramDemand, 
                                    paramOPF, 
                                    Ω_rv,
                                    prob; timelimit = 7200); 
gurobiResultList[100] = gurobiResult;


## scenario size = 200
indexSets = load("src/testData/RTS_24_200/indexSets.jld2")["indexSets"]
paramOPF = load("src/testData/RTS_24_200/paramOPF.jld2")["paramOPF"]
paramDemand = load("src/testData/RTS_24_200/paramDemand.jld2")["paramDemand"]
Ω_rv = load("src/testData/RTS_24_200/Ω_rv.jld2")["Ω_rv"]
prob = load("src/testData/RTS_24_200/prob.jld2")["prob"]

@time gurobiResult = gurobiOptimize!(indexSets, 
                                    paramDemand, 
                                    paramOPF, 
                                    Ω_rv,
                                    prob; timelimit = 7200); 
gurobiResultList[200] = gurobiResult;

save("src/Experiments/ScenariosSizeTest/gurobiResultList.jld2", "gurobiResultList", gurobiResultList)







## ------------------------------  Compute total costs by using different decisions  ----------------------------- ##
## scenario size = 500
indexSets = load("src/testData/RTS_24_500/indexSets.jld2")["indexSets"]
paramOPF = load("src/testData/RTS_24_500/paramOPF.jld2")["paramOPF"]
paramDemand = load("src/testData/RTS_24_500/paramDemand.jld2")["paramDemand"]
Ω_rv = load("src/testData/RTS_24_500/Ω_rv.jld2")["Ω_rv"]
prob = load("src/testData/RTS_24_500/prob.jld2")["prob"]

totalCost = Dict{Int64, Float64}()
for scenarioSize in [20, 50 ,100, 200]
    ## build the second stage problems
    forward2Info_List = Dict{Int64, Forward2Info}();
    for ω in indexSets.Ω
        forward2Info_List[ω] = forward_stage2_model!(indexSets, 
                                                    paramDemand,
                                                    paramOPF,
                                                    Ω_rv[ω]                        ## realization of the random time
                                                    );
    end 

    state_variable = gurobiResultList[scenarioSize].first_state_variable

    
    (D, G, L, B, T, Ω) = (indexSets.D, indexSets.G, indexSets.L, indexSets.B, indexSets.T, indexSets.Ω) 
    (Dᵢ, Gᵢ, in_L, out_L) = (indexSets.Dᵢ, indexSets.Gᵢ, indexSets.in_L, indexSets.out_L) 

    Q = Model( optimizer_with_attributes(()->Gurobi.Optimizer(GRB_ENV), 
                                          "OutputFlag" => 0, 
                                          "Threads" => 0, 
                                          "MIPGap" => 1e-4) 
                                          )
                                          
    @variable(Q, θ_angle[B, 1:T])      ## phase angle of the bus i
    @variable(Q, P[L, 1:T] >= 0)       ## real power flow on line l; elements in L is Tuple (i, j)
    @variable(Q, s[G, 1:T] >= 0)       ## real power generation at generator g
    @variable(Q, 0 <= x[D, 1:T] <= 1)  ## load shedding

    # constraint 3b 3c
    for l in L
      i = l[1]
      j = l[2]
      @constraint(Q, [t in 1:T], P[l, t] <= - paramOPF.b[l] * (θ_angle[i, t] - θ_angle[j, t] + paramOPF.θmax * (1 - state_variable[:zl][l, t] ) ) )
      @constraint(Q, [t in 1:T], P[l, t] >= - paramOPF.b[l] * (θ_angle[i, t] - θ_angle[j, t] + paramOPF.θmin * (1 - state_variable[:zl][l, t] ) ) )
    end

    ## constraint 1d
    @constraint(Q, [l in L, t in 1:T], P[l, t] >= - paramOPF.W[l] * state_variable[:zl][l, t] )
    @constraint(Q, [l in L, t in 1:T], P[l, t] <= paramOPF.W[l] * state_variable[:zl][l, t] )

    ## constraint 1e
    @constraint(Q, [i in B, t in 1:T], sum(s[g, t] for g in Gᵢ[i]) + 
                                          sum(P[(i, j), t] for j in out_L[i]) - 
                                          sum(P[(j, i), t] for j in in_L[i]) 
                                          .== sum(paramDemand.demand[t][d] * x[d, t] for d in Dᵢ[i]) )
    
    ## constraint 1f
    @constraint(Q, [g in G, t in 1:T], s[g, t] >= paramOPF.smin[g] * state_variable[:zg][g, t] )
    @constraint(Q, [g in G, t in 1:T], s[g, t] <= paramOPF.smax[g] * state_variable[:zg][g, t] )

    ## constraint 1g h i j
    for i in B 
      @constraint(Q, [t in 1:T, d in Dᵢ[i]], state_variable[:zb][i, t] >= x[d, t] )
      @constraint(Q, [t in 1:T, g in Gᵢ[i]], state_variable[:zb][i, t] >= state_variable[:zg][g, t])
      @constraint(Q, [t in 1:T, j in out_L[i]], state_variable[:zb][i, t] >= state_variable[:zl][(i, j), t] )
      @constraint(Q, [t in 1:T, j in in_L[i]], state_variable[:zb][i, t] >= state_variable[:zl][(j, i), t] )
    end


    ## objective function
    @objective(Q, Min, sum( prob[ω] * 
                                      ( sum( sum(paramDemand.w[d] * (1 - x[d, t]) for d in D ) for t in 1:Ω_rv[ω].τ - 1 ) )
                                                                                                                                    for ω in Ω )  
              );
    optimize!(Q)
    state_value  = JuMP.objective_value(Q)

    ## stage 2
    c = 0.0
    for ω in indexSets.Ω
        randomVariables = Ω_rv[ω];

        ẑ = Dict(   :zg => state_variable[:zg][:, randomVariables.τ - 1], 
                    :zb => state_variable[:zb][:, randomVariables.τ - 1], 
                    :zl => state_variable[:zl][:, randomVariables.τ - 1]
                    );
        ## modify the constraints according to the first stage state variables
        forward_stage2_modify_constraints!(indexSets, 
                                            forward2Info_List[ω],
                                            i,
                                            ẑ,
                                            randomVariables
                                            );

        ####################################################### solve the model and display the result ###########################################################
        optimize!(forward2Info_List[ω].model);
        c = c + prob[ω] * JuMP.objective_value(forward2Info_List[ω].model);
    end
    u = state_value + c;
    totalCost[scenarioSize] = u;
end

save("src/Experiments/ScenariosSizeTest/totalCost.jld2", "totalCost", totalCost)

